---
layout: post
title:  "面试总结之数据库"
date:   2016-11-07 15:06:40 
categories: 面试经验
tags: 面试总结 数据库 
excerpt: 面试总结之数据库。
---

* content
{:toc}

## 数据库面试总结

比较基础的就不一一介绍了，这篇主要总结一下事务，索引，锁，数据库两个主要引擎。

关于B+Tree，Mysql优化性能调优，博主水平有限，这些之后再做总结！

---

### 事务

事务是作为一个逻辑单元执行的一系列操作，一个逻辑工作单元必须有四个属性，称为 ACID（原子性、一致性、隔离性和持久性）属性，只有这样才能成为一个事务。

* 原子性：一个事务是一个不可分割的工作单位，事务中包括的诸操作要么都做，要么都不做。

* 一致性：事务必须是使数据库从一个一致性状态变到另一个一致性状态。一致性与原子性是密切相关的。

* 隔离性：一个事务的执行不能被其他事务干扰。即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰。

* 持久性：持久性也称永久性（permanence），指一个事务一旦提交，它对数据库中数据的改变就应该是永久性的。接下来的其他操作或故障不应该对其有任何影响。

---

### 事务的SQL操作语句

* 开始事务：begin TRANSACTION;

* 提交事务：commit TRANSACTION;

* 回滚事务：rollback TRANSACTION;

---

### 事务的并发问题

一个数据库可能拥有多个访问客户端，这些客户端都可以并发方式访问数据库。数据库中的相同数据可能同时被多个事务访问，如果没有采取必要的隔离措施，就会导致各种并发问题，破坏数据的完整性。这些问题可以归结为5类，包括3类数据读问题脏读、幻象读和不可重复读）以及2类数据更新问题（第一类丢失更新和第二类丢失更新）。

* 脏读：A事务读取B事务尚未提交的更改数据；

* 不可重复读：A事务读取了B事务已经提交的数据，导致两次读不一致；

* 幻想读：A事务读取了B事务新增的数据，幻象读和不可重复读是两个容易混淆 的概念，前者是指读到了其它已经提交事务的新增数据，而后者是指读到了已经提交事 务的更改数据（更改或删除）；

* 第一类丢失更新：A事务撤销时，把已经提交的B事务的更新数据覆盖了；

* 第二类丢失更新：A事务提交时覆盖了B事务提交的数据；

---

### 事务日志

事务日志主要用于记录对事务的更新操作，包括增加，删除，修改

---

## 索引(数据库术语)

在关系数据库中，索引是一种单独的、物理的数对数据库表中一列或多列的值进行排序的一种存储结构，它是某个表中一列或若干列值的集合和相应的指向表中物理标识这些值的数据页的逻辑指针清单。索引的作用相当于图书的目录，可以根据目录中的页码快速找到所需的内容。

索引提供指向存储在表的指定列中的数据值的指针，然后根据您指定的排序顺序对这些指针排序。数据库使用索引以找到特定值，然后顺指针找到包含该值的行。这样可以使对应于表的SQL语句执行得更快，可快速访问数据库表中的特定信息。

当表中有大量记录时，若要对表进行查询，第一种搜索信息方式是全表搜索，是将所有记录一一取出，和查询条件进行一一对比，然后返回满足条件的记录，这样做会消耗大量数据库系统时间，并造成大量磁盘I/O操作；第二种就是在表中建立索引，然后在索引中找到符合查询条件的索引值，最后通过保存在索引中的ROWID（相当于页码）快速找到表中对应的记录。

---

### 常用的索引

* 唯一索引：唯一索引是不允许其中任何两行具有相同索引值的索引。

	当现有数据中存在重复的键值时，大多数数据库不允许将新创建的唯一索引与表一起保存。数据库还可能防止添加将在表中创建重复键值的新数据。
	
	例如，如果在employee表中职员的姓(lname)上创建了唯一索引，则任何两个员工都不能同姓。
	
* 主键索引：数据库表经常有一列或列组合，其值唯一标识表中的每一行。该列称为表的主键。 在数据库关系图中为表定义主键将自动创建主键索引，主键索引是唯一索引的特定类型。

	该索引要求主键中的每个值都唯一。当在查询中使用主键索引时，它还允许对数据的快速访问。
	
* 聚集索引：在聚集索引中，表中行的物理顺序与键值的逻辑（索引）顺序相同。

	一个表只能包含一个聚集索引。
  
  如果某索引不是聚集索引，则表中行的物理顺序与键值的逻辑顺序不匹配。与非聚集索引相比，聚集索引通常提供更快的数据访问速度。 
  
---

### 索引的优缺点

* 索引的优点

    1.通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。
    
    2.可以大大加快数据的检索速度，这也是创建索引的最主要的原因。
    
    3.可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义。
    
    4.在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间。
    
    5.通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。
    
* 索引的缺点

    1.创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加。
    2.索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大。
    3.当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度。
    
---

### 什么时候应该创建索引？

索引是建立在数据库表中的某些列的上面。在创建索引的时候，应该考虑在哪些列上可以创建索引，在哪些列上不能创建索引。

* 一般来说，应该在这些列上创建索引：

    1.在经常需要搜索的列上，可以加快搜索的速度；
  
    2.在作为主键的列上，强制该列的唯一性和组织表中数据的排列结构；
  
    3.在经常用在连接的列上，这些列主要是一些外键，可以加快连接的速度；
  
    4.在经常需要根据范围进行搜索的列上创建索引，因为索引已经排序，其指定的范围是连续的；
  
    5.在经常需要排序的列上创建索引，因为索引已经排序，这样查询可以利用索引的排序，加快排序查询时间；
  
    6.在经常使用在WHERE子句中的列上面创建索引，加快条件的判断速度。
  
* 不应该创建索引的的这些列具有下列特点：

    1.对于那些在查询中很少使用或者参考的列不应该创建索引。
    
    	 这是因为，既然这些列很少使用到，因此有索引或者无索引，并不能提高查询速度。相反，由于增加了索引，反而降低了系统的维护速度和增大了空间需求。
  
    2.对于那些只有很少数据值的列也不应该增加索引。
    
    	 这是因为，由于这些列的取值很少，例如人事表的性别列，在查询的结果中，结果集的数据行占了表中数据行的很大比例，即需要在表中搜索的数据行的比例很大。增加索引，并不能明显加快检索速度。
  
    3.对于那些定义为text, image和bit数据类型的列不应该增加索引。
    
    	 这是因为，这些列的数据量要么相当大，要么取值很少。
  
    4.当修改性能远远大于检索性能时，不应该创建索引。
    
    	 这是因为，修改性能和检索性能是互相矛盾的。当增加索引时，会提高检索性能，但是会降低修改性能。当减少索引时，会提高修改性能，降低检索性能。
  
* 因此，当修改性能远远大于检索性能时，不应该创建索引。

---

### 索引的实现原理

以后继续更新！博主还没弄明白o(╯□╰)o

---

## Mysql数据库引擎

总的思想：

MyIASM引擎是为了查和增加，效率高。所有功能都围绕这这个

Innodb引擎功能更强（事务等）效率低一些。

---

### Innodb引擎

Innodb引擎提供了对数据库ACID事务的支持，并且实现了SQL标准的四种隔离级别，该引擎还提供了行级锁和外键约束，它的设计目标是处理大容量数据库系统，它本身其实就是基于MySQL后台的完整数据库系统，MySQL运行时Innodb会在内存中建立缓冲池，用于缓冲数据和索引。但是该引擎不支持FULLTEXT类型的索引，而且它没有保存表的行数，当SELECT COUNT(*) FROM TABLE时需要扫描全表。当需要使用数据库事务时，该引擎当然是首选。由于锁的粒度更小，写操作不会锁定全表，所以在并发较高时，使用Innodb引擎会提升效率。但是使用行级锁也不是绝对的，如果在执行一个SQL语句时MySQL不能确定要扫描的范围，InnoDB表同样会锁全表。

---

### MyIASM引擎

MyIASM是MySQL默认的引擎，但是它没有提供对数据库事务的支持，也不支持行级锁和外键，因此当INSERT(插入)或UPDATE(更新)数据时即写操作需要锁定整个表，效率便会低一些。不过和Innodb不同，MyIASM中存储了表的行数，于是SELECT COUNT(*) FROM TABLE时只需要直接读取已经保存好的值而不需要进行全表扫描。如果表的读操作远远多于写操作且不需要数据库事务的支持，那么MyIASM也是很好的选择。

---

### 两种引擎的选择

大尺寸的数据集趋向于选择InnoDB引擎，因为它支持事务处理和故障恢复。数据库的大小决定了故障恢复的时间长短，InnoDB可以利用事务日志进行数据恢复，这会比较快。主键查询在InnoDB引擎下也会相当快，不过需要注意的是如果主键太长也会导致性能问题，关于这个问题我会在下文中讲到。大批的INSERT语句(在每个INSERT语句中写入多行，批量插入)在MyISAM下会快一些，但是UPDATE语句在InnoDB下则会更快一些，尤其是在并发量大的时候。

---

### 两种引擎的索引结构

* MyISAM引擎的索引结构

  MyISAM引擎的索引结构为B+Tree，其中B+Tree的数据域存储的内容为实际数据的地址，也就是说它的索引和实际的数据是分开的，只不过是用索引指向了实际的数据，这种索引就是所谓的非聚集索引。

* Innodb引擎的索引结构

  MyISAM引擎的索引结构同样也是B+Tree，但是Innodb的索引文件本身就是数据文件，即B+Tree的数据域存储的就是实际的数据，这种索引就是聚集索引。这个索引的key就是数据表的主键，因此InnoDB表数据文件本身就是主索引。

  因为InnoDB的数据文件本身要按主键聚集，所以InnoDB要求表必须有主键（MyISAM可以没有），如果没有显式指定，则MySQL系统会自动选择一个可以唯一标识数据记录的列作为主键，如果不存在这种列，则MySQL自动为InnoDB表生成一个隐含字段作为主键，这个字段长度为6个字节，类型为长整形。

  并且和MyISAM不同，InnoDB的辅助索引数据域存储的也是相应记录主键的值而不是地址，所以当以辅助索引查找时，会先根据辅助索引找到主键，再根据主键索引找到实际的数据。所以Innodb不建议使用过长的主键，否则会使辅助索引变得过大。建议使用自增的字段作为主键，这样B+Tree的每一个结点都会被顺序的填满，而不会频繁的分裂调整，会有效的提升插入数据的效率。

---

## 数据库锁(并发控制的基本概念)

### 锁概述：
	
* 锁就是防止其他事务访问指定资源的手段。锁是实现并发控制的主要方法，是多个用户能够同时操纵同一个数据库的数据而不发生数据不一致现象的重要保障。
	
* 一般来说，锁可以防止脏读、不可重复读和幻觉读。脏读就是指当一个事务正在访问数据，并且对数据进行了修改，而这种修改还没有提交到数据库中，这时，另外一个事务也访问这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另外严格事务读到这个数据就是脏数据，依据脏数据所做的操作可能是不正确的。不可重复读是指在一个事务内，多次读同一数据。在这个事务还没有结束时，另外一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改，则第一个事务两次读到的数据可能是不一样的。这样就发生了在一个事务内两次读到的数据是不一样的，因此，称为不可重复读。幻觉读是指当事务不是独立执行时发生的一种现象，例如第一个事务对一个表中的数据进行了修改，这种修改涉及到表中的全部数据行。同时，第二个事务也修改这个表中的数据，这种修改是向表中插入一行新数据。那么，以后就会发生操作第一个事务的用户发现表中还没有修改的数据行，就好像发生了幻觉一样。
  
* 锁是防止其他事务访问指定的资源控制、实现并发控制的一种手段。为了提高系统的性能、加快事务的处理速度、缩短事务的等待时间，应该使锁定的资源最小化。为了控制锁定的资源，应该首先了解系统的空间管理。在SQR SERVER 2005中，最小空间管理单位是页，一个页有8KB。所有的数据、日志、索引都存放在页上。另外，使用页有一个限制，这就是表中的一行数据必须在同一个页上。另外，使用页有一个限制，这就是表中的一行数据必须在同一个页上，不能跨页。页上面的空间管理单位是簇，一个簇是8个连续的页。表和索引的最小占用单位是簇。数据库是有一个或多个表或者索引组成，即有多个簇组成

### 锁的模式

数据库引擎使用不同的锁定资源，这些锁模式确定了并发事务访问资源的方式。根据锁定资源方式的不同，SQR SERVER 2005 提供了4种锁模式：共享锁、排他锁、更新锁，意向锁。

* 共享锁：共享锁也称为S锁，允许并行事务读取同一种资源，这时的事务不能修改访问的数据。当使用共享锁锁定资源时，不允许修改数据的事务访问数据。当读取数据的事务读完数据之后，立即释放所占用的资源。一般地，当使用SELECT 语句访问数据时，系统自动对所访问的数据使用共享锁锁定

* 排他锁：对于那些修改数据的事务，例如，使用INSERT、UPDATE、DELETE语句 ，系统自动在所修改的事务上放置排他锁。排他锁也称X锁，就是在同一时间内只允许一个事务访问一种资源，其他事务都不能在有排他锁的资源上访问。在有排他锁的资源上，不能放置共享锁，也就是说，不允许可以产生共享锁的事务访问这些资源。只有当产生排他锁的事务结束之后，排他锁锁定的资源才能被其他事务使用。

* 更新锁：更新锁也称为U锁，可以防止常见的死锁。在可重复读或可序化事务中，此事务读取数据，获取资源的共享锁，然后修改数据。此操作要求锁转换为排锁。如果两个事务获取了资源上的共享模式锁，然后试图同时更新数据，则一个事务尝试将锁转换为排他锁。共享模式到排他锁的转换必须等待一段时间，因为一个事务的排他锁与其他事务的共享模式锁不兼容，发生锁等待。第二个事务试图获取排他锁以进行更新。由于两个事务都要转换为排他锁，并且每个事务都等待另一个事务释放共享模式锁，因此发生死锁。
					
					若要避免这种潜在的死锁问题，请使用更新锁。一次只有一个事务可以获得资源的更新锁。如果事务修改资源，则更新锁转换为排他锁。
					
* 意向锁：数据库引擎使用意向锁来保护共享锁或排他锁放置在锁层次结构的底层资源上。之所以命名为意向锁，是因为在较低级别锁前可获取它们，因此，会通知意向将锁放置在较低级别上。意向锁有两种用途：
					
					防止其他事务以会使较低级别的锁无效的方式修改较高级别资源。
					
					提高数据库引擎在较高的粒度级别检测锁冲突的效率。
					
					意向锁又分为意向共享锁（IS）、意向排他锁（IX）、以及意向排他共享锁（SIX）。意向共享锁表示读低层次资源的事务的意向，把共享锁放在这些单个的资源上。意向排他锁表示修改低层次的事务的意向，把排他锁放在这些单个资源上。意向排他锁包括意向共享锁，它是意向共享锁的超集。使用意向排他的共享锁表示允许并行读取顶层资源的事务的意向，并且修改一些低层次的资源，把意向排他锁这些单个资源上。例如，表上的一个使用意向排他的共享锁把共享锁放在表上，允许并行读取，并且把意向排他锁放在刚要修改的页上，把排他锁放在修改的行上。每一个表一次只能有一个使用意向排他的共享锁因为表级共享锁阻止对表的任何修改。使用意向排他的共享锁和意向排他锁的组合

---

### 分布式数据库系统中怎么进行并发控制(一道面试题)

博主当时回答的就是使用数据库表的主键，实现思路就是加锁的时候向数据库中插入一条记录，那么成功插入的操作就获取到了锁，然后解锁时，删除这条记录即可。当时也不知道对不对，胡乱说的，后来回来查资料发现可以使用时间戳方法来进行并发控制。

好像还可使使用Redis进行并发控制！

还有面试被问到一些概念性的东西尽量转换成自己的理解然后去解释，死背概念没有用！！

---

## 参考资料

* [MySQL数据库引擎详解](http://www.2cto.com/database/201503/385669.html)



