---
layout: post
title:  "面试总结之多线程(1)"
categories: 多线程
tags:  线程 多线程 线程安全
author: HcxCode
---

* content
{:toc}

总的来说，每次面试必不可少的就是关于线程方面的问题，Java语言一个重要的特点就是内置了对并发的支持，让Java大受企业和程序员的欢迎。

本文介绍主要从线程的基本概念开始，涉及线程的创建、使用、选择哪种创建方式更好，以及并发编程中出现的问题，Java内存模型，如何处理死锁，竞态条件，内存冲突和线程安全等并发问题，还有经典的多线程面试题。以下全部来自于面试时总结的内容，如有不当的地方，欢迎批评交流~

---

## 多线程的基本概念

### 什么是线程

* 线程是操作系统能够进行运算调度的最小单位，它被包含在进程之中，是进程中的实际运作单位。

* 经典面试题：进程与线程的区别

  1.进程：每个进程都有独立的代码和数据空间（进程上下文），进程间的切换会有较大的开销，一个进程包含1--n个线程。
  
　2.线程：同一类线程共享代码和数据空间，每个线程有独立的运行栈和程序计数器(PC)，线程切换开销小。

　3.线程和进程一样分为五个阶段：创建、就绪、运行、阻塞、终止。

　4.多进程是指操作系统能同时运行多个任务（程序）。

　5.多线程是指在同一程序中有多个顺序流在执行。

### 如何在Java中实现线程

* 继承Thread类;

```
class T extends Thread{  
    //重写run()方法  
    public void run(){  
        System.out.println(this.getName());  
    }  
} 
```

* 实现Runnable接口;

```
class T implements Runnable{  
    //重写run()方法  
    public void run(){  
        System.out.println(Thread.currentThread().getName());  
    }  
} 
```

* 实现Callable接口;

```
public interface Callable<V> {  
    /** 
     * Computes a result, or throws an exception if unable to do so. 
     * 
     * @return computed result 
     * @throws Exception if unable to compute a result 
     */  
    V call() throws Exception;  
}
```

Callable接口和Runnable接口相似，区别就是Callable需要实现call方法，而Runnable需要实现run方法；并且，call方法还可以返回任何对象，无论是什么对象，JVM都会当作Object来处理。但是如果使用了泛型，我们就不用每次都对Object进行转换了。

### 用Runnable还是Thread?

在程序开发中只要是多线程肯定永远以实现Runnable接口为主，因为实现Runnable接口相比继承Thread类有如下好处：

1. 避免点继承的局限，一个类可以继承多个接口。
2. 适合于资源的共享。

### Thread 类中的start() 和 run() 方法有什么区别？

1. Thread.start ()方法(native)启动线程，使之进入就绪状态，当 cpu 分配时间该线程时，由 JVM 调度执行 run ()方法。

2. 调用start（）后，线程会被放到等待队列，等待CPU调度，并不一定要马上开始执行，只是将这个线程置于可动行状态。然后通过JVM，线程Thread会调用run（）方法，执行本线程的线程体。先调用start后调用run，这么麻烦，为了不直接调用run？就是为了实现多线程的优点，没这个start不行。

#### 为什么需要 run ()和 start ()方法？

我们可以只用 run ()方法来完成任务吗？

* 答案：我们需要 run ()&start ()这两个方法是因为 JVM 创建一个单独的线程不同于普通方法的调用，所以这项工作由线程的 start 方法来完成，start 由本地方法实现，需要显示地被调用，使用这俩个方法的另外一个好处是任何一个对象都可以作为线程运行，只要实现了 Runnable 接口，这就避免因继承了 Thread 类而造成的 Java 的多继承问题。