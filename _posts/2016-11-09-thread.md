---
layout: post
title:  "面试总结之多线程(1)"
date:   2016-11-09 19:46:05
categories: 多线程
tags: 多线程 线程安全 内存模型
excerpt: 多线程学习笔记。
---

* content
{:toc}

## 多线程面试总结

总的来说，每次面试必不可少的就是关于线程方面的问题，Java语言一个重要的特点就是内置了对并发的支持，让Java大受企业和程序员的欢迎。

本文介绍主要从线程的基本概念开始，涉及线程的创建、使用、选择哪种创建方式更好，以及并发编程中出现的问题，Java内存模型，如何处理死锁，竞态条件，内存冲突和线程安全等并发问题，还有经典的多线程面试题。以下全部来自于面试时总结的内容，如有不当的地方，欢迎批评交流~

---

## 多线程的基本概念

### 什么是线程

* 线程是操作系统能够进行运算调度的最小单位，它被包含在进程之中，是进程中的实际运作单位。

* 经典面试题：进程与线程的区别

  1.进程：每个进程都有独立的代码和数据空间（进程上下文），进程间的切换会有较大的开销，一个进程包含1--n个线程。
  
　2.线程：同一类线程共享代码和数据空间，每个线程有独立的运行栈和程序计数器(PC)，线程切换开销小。

　3.线程和进程一样分为五个阶段：创建、就绪、运行、阻塞、终止。

　4.多进程是指操作系统能同时运行多个任务（程序）。

　5.多线程是指在同一程序中有多个顺序流在执行。

---

### 如何在Java中实现线程

* 继承Thread类;

```
class T extends Thread{  
    //重写run()方法  
    public void run(){  
        System.out.println(this.getName());  
    }  
} 
```

* 实现Runnable接口;

```
class T implements Runnable{  
    //重写run()方法  
    public void run(){  
        System.out.println(Thread.currentThread().getName());  
    }  
} 
```

* 实现Callable接口;

```
public interface Callable<V> {  
    /** 
     * Computes a result, or throws an exception if unable to do so. 
     * 
     * @return computed result 
     * @throws Exception if unable to compute a result 
     */  
    V call() throws Exception;  
}
```

Callable接口和Runnable接口相似，区别就是Callable需要实现call方法，而Runnable需要实现run方法；并且，call方法还可以返回任何对象，无论是什么对象，JVM都会当作Object来处理。但是如果使用了泛型，我们就不用每次都对Object进行转换了。

---

### 用Runnable还是Thread?

在程序开发中只要是多线程肯定永远以实现Runnable接口为主，因为实现Runnable接口相比继承Thread类有如下好处：

1. 避免点继承的局限，一个类可以继承多个接口。
2. 适合于资源的共享。

---

### Thread 类中的start() 和 run() 方法有什么区别？

1. Thread.start ()方法(native)启动线程，使之进入就绪状态，当 cpu 分配时间该线程时，由 JVM 调度执行 run ()方法。

2. 调用start（）后，线程会被放到等待队列，等待CPU调度，并不一定要马上开始执行，只是将这个线程置于可动行状态。然后通过JVM，线程Thread会调用run（）方法，执行本线程的线程体。先调用start后调用run，这么麻烦，为了不直接调用run？就是为了实现多线程的优点，没这个start不行。

---

#### 为什么需要 run ()和 start ()方法？

我们可以只用 run ()方法来完成任务吗？

* 答案：我们需要 run ()&start ()这两个方法是因为 JVM 创建一个单独的线程不同于普通方法的调用，所以这项工作由线程的 start 方法来完成，start 由本地方法实现，需要显示地被调用，使用这俩个方法的另外一个好处是任何一个对象都可以作为线程运行，只要实现了 Runnable 接口，这就避免因继承了 Thread 类而造成的 Java 的多继承问题。

---


## Java内存模型

这一部分只是面试的时候看过一点，先总结一些基础的，以后在继续补充~

---

### Java内存模型是什么

Java内存模型规定和指引Java程序在不同的内存架构、CPU和操作系统间有确定性地行为。它在多线程的情况下尤其重要。Java内存模型对一个线程所做的变动能被其它线程可见提供了保证，它们之间是先行发生关系。这个关系定义了一些规则让程序员在并发编程时思路更清晰。比如，先行发生关系确保了：

1. 线程内的代码能够按先后顺序执行，这被称为程序次序规则。
2. 对于同一个锁，一个解锁操作一定要发生在时间上后发生的另一个锁定操作之前，也叫做管程锁定规则。
3. 前一个对volatile的写操作在后一个volatile的读操作之前，也叫volatile变量规则。
4. 一个线程内的任何操作必需在这个线程的start()调用之后，也叫作线程启动规则。
5. 一个线程的所有操作都会在线程终止之前，线程终止规则。
6. 一个对象的终结操作必需在这个对象构造完成之后，也叫对象终结规则。
7. 可传递性



---

### 并发编程中的三个概念

* 原子性：即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。
	
	i的自增不是原子性操作！
	
* 可见性：是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。

* 有序性：即程序执行的顺序按照代码的先后顺序执行。(具体事例介绍以后补充~)

### volatile关键字

关于volatile这个关键字博主也是很陌生，没有实践过，只是看书时遇到过。

#### volatile关键字的两层语义

一旦一个共享变量（类的成员变量、类的静态成员变量）被volatile修饰之后，那么就具备了两层语义：

1. 保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。

2. 禁止进行指令重排序。

先看一段代码，假如线程1先执行，线程2后执行：

```
//线程1
boolean stop = false;
while(!stop){
    doSomething();
}
 
//线程2
stop = true;
```

这段代码是很典型的一段代码，很多人在中断线程时可能都会采用这种标记办法。但是事实上，这段代码会完全运行正确么？即一定会将线程中断么？不一定，也许在大多数时候，这个代码能够把线程中断，但是也有可能会导致无法中断线程（虽然这个可能性很小，但是只要一旦发生这种情况就会造成死循环了）。

　　下面解释一下这段代码为何有可能导致无法中断线程。在前面已经解释过，每个线程在运行过程中都有自己的工作内存，那么线程1在运行的时候，会将stop变量的值拷贝一份放在自己的工作内存当中。

　　那么当线程2更改了stop变量的值之后，但是还没来得及写入主存当中，线程2转去做其他事情了，那么线程1由于不知道线程2对stop变量的更改，因此还会一直循环下去。

　　但是用volatile修饰之后就变得不一样了：

　　第一：使用volatile关键字会强制将修改的值立即写入主存；

　　第二：使用volatile关键字的话，当线程2进行修改时，会导致线程1的工作内存中缓存变量stop的缓存行无效（反映到硬件层的话，就是CPU的L1或者L2缓存中对应的缓存行无效）；

　　第三：由于线程1的工作内存中缓存变量stop的缓存行无效，所以线程1再次读取变量stop的值时会去主存读取。

　　那么在线程2修改stop值时（当然这里包括2个操作，修改线程2工作内存中的值，然后将修改后的值写入内存），会使得线程1的工作内存中缓存变量stop的缓存行无效，然后线程1读取时，发现自己的缓存行无效，它会等待缓存行对应的主存地址被更新之后，然后去对应的主存读取最新的值。

　　那么线程1读取到的就是最新的正确的值。

#### volatile保证原子性吗？

待学习~

#### volatile能保证有序性吗？

在前面提到volatile关键字能禁止指令重排序，所以volatile能在一定程度上保证有序性。

　　volatile关键字禁止指令重排序有两层意思：

　　1. 当程序执行到volatile变量的读操作或者写操作时，在其前面的操作的更改肯定全部已经进行，且结果已经对后面的操作可见；在其后面的操作肯定还没有进行；

　　2. 在进行指令优化时，不能将在对volatile变量访问的语句放在其后面执行，也不能把volatile变量后面的语句放到其前面执行。

#### volatile的原理和实现机制

前面讲述了源于volatile关键字的一些使用，下面我们来探讨一下volatile到底如何保证可见性和禁止指令重排序的。

　　下面这段话摘自《深入理解Java虚拟机》：

　　“观察加入volatile关键字和没有加入volatile关键字时所生成的汇编代码发现，加入volatile关键字时，会多出一个lock前缀指令”

　　lock前缀指令实际上相当于一个内存屏障（也成内存栅栏），内存屏障会提供3个功能：

　　1. 它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成；

　　2. 它会强制将对缓存的修改操作立即写入主存；

　　3. 如果是写操作，它会导致其他CPU中对应的缓存行无效。

#### 参考资料

* [深入理解Java虚拟机](http://www.linuxidc.com/Linux/2014-09/106869.htm)

* [Java并发编程：volatile关键字解析](http://www.cnblogs.com/dolphin0520/p/3920373.html)

## 总结

今天总结先这么多，有很多的地方我也是进行了摘抄，学习别人博客是一种提升自己的好方法，大家可以去尝试一下！！

另外面试过程中关于多线程的问题大概就这么多，因为没有整理完，所以后面会在写一篇关于锁、线程安全的文章！

欢迎大家交流~~
