---
layout: post
title:  "剑指offer思路解析"
date:   2016-11-10 14:39:05
categories: 算法
tags: 剑指offer 算法
excerpt: 剑指offer算法解析学习笔记。
---

* content
{:toc}



九月下旬去美团面试，终止于三面，基础不扎实，更多的原因是算法太烂~这是二面面试官给我的评价o(╯□╰)o

不过那会半路出家确实不太重视算法这方面，以为只掌握Java语言就可以啦~所以吃一堑长一智~

## 剑指offer

当时美团面试回来后，正好快赶上国庆，所以那几天窝在宿舍天天看剑指offer，里面的算法全部用C实现，大致意思懂，但是自己练习起来很费劲，所以找了很多Java的版本，需要的可以联系我~

---

## 思路整理

当时整理好的思路都是全文字的，现在做一个归类整理然后贴上来，具体的代码整理好之后再做补充。

---

### 链表类型习题

* 链表中倒数第K个结点

	1. 思路：设置两个指针在头部，第一个指针向前移动K-1步，另外一个指针再开始移动，两个指针同步移动，两者一直保持K-1，那么当第一个指针到达队尾的时候第二个指针刚好是倒数第K个结点。
  2. 注意事项：如果输入的pListHead为空指针，那么导致空指针异常。(返回NULL)如果输入的链表总的结点小于K，那么当向前走K-1步的时候会程序崩溃。（加一个for循环判断）输入的参数K为0的时候，K是一个无符号证书，那么K-1不是为-1，而是0xFFFFFFFF，那么程序也会崩溃，需要考虑这三种特例情况。(返回NULL)。
	4. 问题拓展：求链表的中间结点：定义两个指针，一个指针每次走两步，一个每次走一步，当快指针走完，那么慢指针刚好在中间。
  5. 判断一个链表是否有环：定义两个指针，一个指针每次走两步，一个每次走一步，判断快的指针在中间追上慢的指针，说明有环，如果快的指针走到了链表的末尾都没追上慢指针，则没有环。
	6. 思路拓展：当用一个指针不能解决问题，那么就用两个，一个遍历速度快，一个遍历速度慢，或者一个向前先走若干步。
	
---

* 反转链表

	1. 思路：正确的反转一个链表，就是调整链表中指针的方向，当我们把一个结点的指针反转后会无法遍历到下一个结点，导致链表断开，所以当我们进行操作的时候要先保存下一个结点，以防止断开。所以当我们操作一个结点的时候，首先要知道他的前一个结点和后一个结点，用三个指针分别保存当前遍历到的结点，他的前一个结点及后一个结点。反转后头结点是曾经的尾结点，那么他没有下一个结点。
	2. 注意事项：输入的链表头指针为NULL或者整个链表只有一个结点时，程序崩溃。反转后的断裂。返回的反转之后的头结点不是原链表的尾结点。
	
---

* 合并两个排序的链表

	1. 类似于归并排序。
	2. 每次判断两个链表的头结点，并选取小的作为下一个结点，然后比较下一轮，典型的递归过程。
	3. 注意事项：当输入的为空的链表，那么就会引入空的指针，那么返回的就是另外一个链表。
	
---

* 在O(1)时间删除链表结点

	1. 思路：通过覆盖的方式，比如要删除i结点，那么先把i的下一个结点j的内容复制到i，然后把i的指针指向结点j的下一个结点，然后删除j结点，相当于把i结点删除掉。
	2. 特殊：要删除的结点位于尾部，那么就遍历到尾部的前一个结点，进行删除，如果只有一个结点，那么删除后要将结点设为Null，如果要删除的结点不在链表中。
	3. 删除一个节点，不在于删除它，将后面的结点覆盖它，是另外一种思路。
	
---

* 复杂链表的复制

	1. 分治法的思想。
	2. 首先复制原始链表上的每个结点N创建N“，然后将这些创建出来的用指针连接起来，并把<N,N">的配对信息用一个哈希表保存起来，第二步设置每个链表的虚指针，如果原始链表中N指向S，那么N”就应该指向S“，这样就可以免除重新遍历查找新的链表，使用空间换取时间。
	3. 第二种方法：第一步还是创建N”的新链表，然后将创建好的新的链表链接在N后面，然后复制虚指针，那么原本N指向S，那么N'应该是N的指向的下一个结点，同样S“也是S的下一个指向的结点，即A A" B B" C C" D D"这样，第三步就是把这个链表拆分，把奇数位置的结点用原始指针相连，把偶数部分用原始指针相连可以分别得到复制链表。
	
---

* 两个链表的第一个公共结点

	1. 首先从第一个公共结点开始，之后两个链表的结点都是重合的，是一个Y型。
	2. 考虑到两个链表的长短不同，但是从公共结点后的长度是相同的，那么从后向前遍历，那么使用栈可以完成，需要使用两个辅助栈。
	3. 第二种，找到链表较长的，让其比短的先走几个结点，然后在一同遍历，找到公共结点。时间复杂度(m+n)。
	
---

### 数组类型习题

* 调整数组顺序使奇数位于偶数前面

	1. 思路：使用两个指针，一个指向第一个元素，一个指向最后一个元素，相向而行，如果第一个指的是偶数，第二个是奇数，那么久交换这两个数字。
	2. 同类型：数组按大小分成两个部分，所有负数都在非负数前面。数组分成能被3整除的都在不能被3整除的前面，同一个类型的题只是需要修改判断的标准，大的逻辑不用修改，那么将函数解耦成1：判断数字应该在数组的前面还是后面。2：拆分数组操作。
	
---




* 最小的K个数

	1. 输入n个数，找出其中最小的k个数。
	2. 思路：基于上一题中的思路，使用快速排序中的思想，基于数组中第K个数字来调整，使得比第K个数字小的都在左边，那么最后调整完毕就可以获得，时间复杂度为n，但是这种方法的限制是要修改数组。
	3. 思路：空间换时间，创建一个大小为K的数据容器来存储最小的K个数字，从数组中读取数字，如果容器小于K个数字就直接放入，如果容器存放满了，那么就需要去替换，因此要做的三件事：在k个整数中找到最大值，有可能在这个容器中删除最大数，有可能要插入一个新的数字，所以使用一个二叉树来实现这个容器，时间复杂度logK，那么对于n个数字就是nlogK。因为使用二叉树实现容器，那么容易想到使用最大堆，在最大堆中根节点的值总是大于子树中任意结点的值，所以我们可以在O(1)得到K个数字中的最大值，但是需要logK来删除插入，这个适合海量数据的查找。
	
---

* 连续子数组的最大和

	1. 数组为{1，-2，3，10，-4，7，2，-5}，那么我们先初始化一个和为0，当加上第一个第二个数字后为-1，在加上第三个后为2，那么得到的和2比3小，说明从第一个子数组开始的和会小于从第三个数字开始的和，那么就不需要考虑前面的子数组。在后面加上一些数字后，发现加上某些数字加上后和变小了，所以要保存下来前面的和，即有可能为最大的子数组和，在往后如果加上其他的数字超过这个和，那么就进行更新，当小于这个和时，不用更新。这样可以得到最后的最大连续子数组的和。
	2. 需要考虑无效的输入，输入的数组参数为空指针、数组的长度小于等于0怎么处理，需要定义一个全局变量来标记是否输出无效。
	3. 另一种思路：动态规划:当以第i-1个数字结尾的子数组中所有数字的和小于0时，如果把这个负数与第i个数相加，那么结果还要小，所以这种情况下以第i个数字结尾的子数组就是第i个数字本身，如果以第i-1个数字结尾的子数组中所有数字的和大于0，与第i个数字累加就得到以第i个数字结尾的子数组中所有数字的和。
	
---

* 把数组排成最小的数

	1. 比如一个数组中有三个数{3，32，321}，那么排出最小的数为321323。
	2. 直接的做法就是求得这个数组的全排列，那么n个数字有n!个排列，太复杂。
	3. 确定一种规则，确定两个数字哪一个应该排在前面，而不是仅仅比较哪个数字更大，比如两个数字m,n，可以拼接成nm,mn，如果mn<nm，那么也就是m应该排在n前面，我们定义此时m<n，反之nm<mn，我们定义n<m，如果mn=nm，那么m=n，接下来考虑如何拼接，两个数字拼接可能超过Int范围，那么把数字转换成字符串进行拼接。
	
---

* 数字在排序数组中出现的次数

	1. 比如1，2，3，3，3，3，4，5，那么3出现了四次。
	2. 使用二分查找法找到第一个3以及最后一个3，这样最快。
	3. 先拿中间的数字与其比较，中间的数字比k大，那么就在前半段找，中间的数字比k小，那么就在后半段找，如果相等，就需要判断是否为第一个k，不是则需要去前半段找，这样使用递归可以找到第一个3。同理可以找到最后一个3，利用下标可以求出次数。
	
---

* 数组中只出现一次的数字

	1. 一个整型数组里除了两个数字之外，其他数字都出现了两次，找出这两个出现一次的数字{2，4，3，6，3，2，5，5}，输出4，6。
	2. 可以先考虑只有一个数字只出现了一次，其他的出现了两次，使用异或运算的一个性质，任何一个数字异或他自己等于0，也就是说我们从头到尾依次异或数组中的每一个数字，那么最终的结果刚好是那个只出现一次的数字，因为其他都抵消了。
	3. 利用上面的思想，我们可以把数组分成两个子数组，每个子数组中包含一个只出现一次的数字，这样可以分别求出。
	4. 一个数组异或的结果肯定不为0，也就是说这个结果数字的二进制表示中至少有一位为1，我们找到第一个位1的位置，记作第n位，现在就以第n位是不是为1来将原数组分成两个子数组，第一个子数组的每个数字的第n位都是1，另外一个都是0，比如{2，4，3，6，3，2，5，5}，依次对数组中每一个数字进行异或后，得到的结果用二进制表示0010，那么倒数第二位为1，那么就以这个为基准分，{2，3，6，3，2}的倒数第二位都是1，所以正确分开。
	
---

* 输入一个递增的排序的数组和一个整数s，在数组中找到两个数，是的他们的和正好是s，如果有多对数字的和等于s，输入任意一对即可

	1. 笨方法：固定一个数字，依次找后面满足要求的数字。
	2. 第二种：选择两个数字，如果恰好等于，那不需要再找，如果比s小，那么考虑选择较小的数字后面的数字，如果大于s，那么考虑较大数字前面的数字，定义两个指针，分别指向第一个和最后一个，循环的条件就是较小的数字一定在较大数字前面。
	
---

### 数字与字符类型习题

* 数组中出现次数超过一半的数字

	1. 思路：如果对数组进行排序，那么排序后中间的数字一定是超过数组一半的数字，但是时间复杂度为nlogn，那么我们可以随机选取一个数，根据快速排序的思想，将比它大的放在右边，小的放在左边，如果选取的这个数正好为n/2，那么就可以，如果大于n/2，说明需要找的数在左边，那么递归左边。否则右边。
	2. 还需要考虑输入的参数如果是一个指针，如果为null怎么处理，或者数组中出现频率最高的都没有超过一般怎么半，对其进行处理。
	3. 另一种解法：一个数字出现的次数超过一半，那么就表明其他数字出现的次数和都比它小，所以可以保存两个值，一个是数组中的数字，一个是次数，如果下一个相同就加1，不同就减1，如果次数为0，那么久保存下一个数字，并设置次数为1，因为我们要找的数字出现的次数比其他的数字出现次数之和还要多，所以要找的数字肯定是最后一次把次数设为1的时候对应的数字。
	
---

* 第一个只出现一次的字符

	1. 比如abaccdeff，那么输出b
	2. 创建一个容器存放每个字符出现的次数，这个容器的作用就是把一个字符映射成一个数字，哈希表
	3. 哈希表的键值是字符，值是出现的次数，实现一个简易的哈希表，字符是一个长度为8的数据类型，所以有256种可能，所以数组大小为256.这样第一次扫描将次数记录，第二次扫描寻找第一个出现一次的字符即可
	4. 拓展：输入两个字符串，从第一个字符串中删除第二个字符串中出现的所有字符，那么也可以用这种思想，用一个哈希表存储第二个字符串，从头到尾扫描第一个字符串，用O(1)的时间就可以知道该字符是否存在第二个字符串中
	5. 删除字符串中所有出现重复的字符，比如goole，输出为gole，那么可以创建一个布尔型数组实现简单的哈希表，通过元素的下标看做ASCII码对应的字符在字符串中是否出现，可以先将字符中所有的字符设成false，那么g的ASCII码为103，那么设为true，当下一个g来时，删除。
	6. 两个单词出现的字母相同，并且每个字母出现的次数相同，成为变位词，比如slient与listen，创建一个数组实现简单的哈希表，用来统计字母出现的次数，每个次数都加1，接下来扫描下一个单词时，碰到每个相同的字符减一，如果最后为0，那么是变位词

---

* 丑数

	1. 把只包含因子2、3、5的数成为丑数，例如6、8都是丑数，但14不是，因为他包含因子7，习惯上把1当做第一个丑数。
	2. 进行因子辗转相除，但是比较复杂.
	3. 利用数组保存已经找到的丑数，用空间换时间：一个丑数应该是另外一个丑数乘以2、3、5的结果，因此创建一个数组，里面是排好序的丑数，每一个丑数都是前面的丑数乘以2、3、5得到。那么假如数组中最大的丑数为M，那么想要得到下一个，就用前面的丑数乘以2、3、5，如果小于M，那么肯定已经存在，大于M，那就取第一个大于M的结果，因为数组是排好序的。
	4. 前面提到每个丑数都分别乘以2、3、5，但是其实是不用的，对于乘以2而言肯定存在一个丑数T。
	
---

* 从1到n整数中1出现的次数

	1. 假如n为12，那么出现1的为1，10，11，12，所以有5个1。
	2. 思路：通过累加判断1的次数肯定不行，将一个数字分成两段，加入n为21345，那么分成1-1345，1346-21345，那么在10000~19999中出现的次数为10的四次方，也就是对于5位数比如10000~12345出现的为2345+1次，那么在其他4位数中，可以分成两段1356~21345分成1356~11345和11346~21345，那么对于剩下的4位选取其中一位为1，其余三位在0~9之间选择，排列组合为2000次，那么1~1345中出现的次数可以用递归求。
	3. 总体的思路就是每次去掉最高位做递归，递归的次数和位数相同。
	
---

* 字符串的排列

	1. 输入一个字符串，打印该字符串的所有可能的排列组合
	2. 同样使用分治法，将字符串看成两部分，那么第一部分是第一个字符，后面的字符串是另外一部分。首先求所有可能出现在第一个位置的字符，即把第一个字符和后面的左右的字符交换。第二步，固定第一个字符，求后面所有的排列，这个时候我们把后面的部分在分成两部分，依次递归。
	3. 扩展：如果求字符的所有的组合比如a,b,c,ab,ac,bc,abc呢，当交换字符串中的两个字符时，虽然能得到两个不同的排列，但是是一个相同的组合。那么如果输入n个字符，则能构成长度为1长度为2长度为n的组合，那么在求n个字符的长度为m的组合的时候，把n分成两部分，第一个字符和后面所有的字符，当包含第一个字符的时候，后面一部分取m-1个字符，如果不包含第一个字符，在后面字符选取m个字符，也就是说分别求n-1个字符串长度为m-1的组合，以及求n-1个字符的长度为m的组合。

---


### 其他类型(树、栈等)习题

* 树的子结构

	1. 判断B是不是A的子结构，也就是判断A中是否包含一部分与B相同。
	2. 思路：第一步在树A种找到和B的根节点一样的结点R，第二步再判断树A种以R为根结点的子树是不是包含和树B一样的结构。
	3. 在第一步中寻找相同的根结点，也就是对二叉树的遍历，没有太多要求则使用递归，但是注意边界的检查，即检查空指针，当树A或者树B为空的时候，定义响应的输出。第二步判断子树是否相等，同样可以使用递归进行判断。递归的终止条件就是找到了A与B相同的结构。否则继续向下判断。
	4. 注意事项：二叉树有大量的指针，每次使用指针都应该考虑是否为NULL。
	
---

* 二叉树的镜像

	1. 思路：求树的镜像的过程就是遍历树的同时交换非叶结点的左右子结点。
	2. 通过前序遍历，如果发现有子节点，那么就交换。
	
---

* 顺时针打印矩阵

	1. 思路：看成绕圈打印，控制多个循环以及多个边界条件，主要是控制打印一圈的功能以及停止循环打印的边界条件，由于是个正方形，那么左上角的为0，0或者1，1 ，2，2，所以当6*6矩阵的时候那么最后会有四个数字，那么6>2*2，所以当宽度大于start*2的时候继续循环打印。
	2. 打印一圈的功能：第一步是必须的，第二步的前提条件是终止行号大于起始行号，需要打印第三步的前提条件是圈内至少有两行两列，也就是说除了要求终止行号大于起始行号之外还要终止列号大于起始列号。同理打印第四步的条件是至少有三行两列

---

* 包含min函数的栈

	1. 使用一个辅助栈，当往栈中压入数据的时候，比如第一个为3，那么3是最小的，当在压入一个4的时候，那么辅助栈继续压入3，一直保持最小的，当压入2的时候，辅助栈压入2，所以由此可见。当栈顶的最小元素2被弹出后，那么辅助栈也弹出，继续保持最最小的元素。

---

* 栈的压入、弹出序列

	1. 比如一个序列的入栈顺序为1，2，3，4，5。那么他的出栈顺序有很多种，但是4，3，5，1，2肯定不是该栈的弹出序列
	2. 那么就建立一个辅助栈，把输入的第一个序列的数字依次压入该辅助栈，并按照第二个序列的顺序依次从该栈中弹出数字，比如弹出序列4，5，3，2，1。那么首先把4压入栈中，那么1，2，3都应该先压入，弹出4后希望下一个为5，判断栈顶元素，否则继续压入5，然后弹出。使得每次操作前都处于栈顶

---

* 从上往下打印二叉树

	1. 思路：广度优先遍历二叉树
	2. 实现一个队列，首先将根节点放入队里中，并遍历他的两个子结点放入队列中，当取到左结点的时候，遍历这个结点的子结点并放入队列中，取出左结点，然后遍历右结点，并将右结点的两个子结点放入队列中，然后依次遍历出队列。
	3. 拓展：不管是广度优先遍历一个有向图还是一棵树，都要用到队列，第一步把起始队列或者根节点放入队列中，接下来每一次从队列的头部取出一个结点，遍历每个结点之后把从它能到达的结点都一次放入队列中，重复遍历，直到队列中的结点遍历完

---

* 二叉搜索树的后序遍历序列

	1. 输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。
	2. 后序遍历可知最后一个节点为根节点，那么前面数据分成两个部分，前面左子树比根节点小，后面右子树比根节点大，那么在可以确定前面数据部分的最后一个值也是左子树的根节点，比如5，7，6。6是左子树的根节点，那么5是左结点，7是右结点。二叉搜索树就是左子树比根节点小，右子树比根节点大。
	3. 所以根据此规则可以判断是否是一个二叉搜索树的后续序列
	4. 如果要求处理一颗二叉树的遍历序列，先找到二叉树的根节点，在基于根节点把整棵树的遍历序列拆分成左子树和右子树的子序列，然后在递归处理这两个子序列
	5. 同类型：给一个整数数组，判断该数组是否是一个二叉树的前序遍历序列，那么第一个元素为根节点，规律类似。

---

* 二叉树中和为某一值的路径

	1. 即输入一个二叉树和一个整数，求二叉树中结点值的和为输入整数的所有路径，从根节点开始往下一直到叶节点所经过的节点形成一条路径。
	2. 那么从根节点开始遍历，首先应该是前序遍历，每次遍历的时候都保存路径，到达子节点的时候，发现不满足的时候需要返回根节点去遍历右结点，那么之前保存的路径需要删除，即返回一步就删除一步。这个可以用一个栈来保存走过的路径，符合就留下，不符合返回的时候就弹出

---

* 二叉搜索树与双向链表

	1. 将一颗二叉搜索树改变成排序好的双向链表，可知原先指向左子树的指针调整为链表中指向前一个结点的指针，原先指向右子节点的指针调整为链表中指向后一个结点指针，将其分成三部分，左子树的最大值与根节点相连，根节点与右子树的最小值相连，从而获得双向链表
	2. 把问题拆分成三个小问题，分别使用递归得到排序好的左子树、右子树，然后相连接

---

## 总结

好长时间不看之前的笔记，很生疏，所以今天只是把原先的笔记排版贴上来，之后在慢慢整理！

建议大家还是好好看看剑指offer这本书，里面的思路还是很棒的！！

## 参考资料

* [剑指offer专栏](http://blog.csdn.net/column/details/mmc-offer.html)


	
	
	
	